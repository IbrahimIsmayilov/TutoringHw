# Question (Fix Binary Search)
# The function below does not work when called with binary_search([10, 20], 20). Why? What is the problem? 
# Identify the reason and fix the implementation of the binary search.
# Reason: With the original code, the value of left was always staying the same despite being less than the target number. The index has to be incremented to not include the middle number in the  new scope, or decrement in the case of the target number being less. 
def binary_search(lst, target):
    left = 0
    right = len(lst) - 1
    while left <= right:
        middle_idx = (left + right) // 2
        middle_elem = lst[middle_idx]
        if middle_elem < target:
            # lst = lst[middle_idx:]
            left = middle_idx + 1
            # we go to the right
        elif middle_elem > target:
            # we go to the left
            # lst = lst[:middle_idx]
            right = middle_idx - 1
        else:
            # We found the element
            print(f"found the element at: {middle_idx}")
            break


    

binary_search([10, 20], 20)

# Question
# Complete the body of the funciton so it finds the random number generated by the computer using binary search.
def find_num():
    # The code below generates random number between 1 and 100
    import random
    num = random.randint(1, 100)  # random integer between 1 and 10 (inclusive)

    left = 1
    right = 100
    while left <= right:
        middle_num = (left + right) // 2
        if middle_num < num:
            left = middle_num + 1
        elif middle_num > num:
            right = middle_num - 1
        else:
            print(f"found the number, it is: {num}")
            break

find_num()


# ****************************************
# DO NOT USE ANY OF THE BUILT IN         *
# METHODS TO SOLVE THE SORTING QUESTIONS *
# ****************************************
# Question (New list sort)
# There are lots of ways how sorting can be performed with a list.
# I want you to develop an intuition before jumping into a well known sorting algorithms.

# Complete the body of the function so it returns a new list that is the sorted version of the original list.
def my_sort(lst: list[int]) -> list[int]:
    new_list = []

    while lst:  
        smallest = lst[0]
        for elem in lst:
            if elem < smallest:
                smallest = elem
        new_list.append(smallest)
        lst.remove(smallest)  

    return new_list

print(my_sort([9, 0, 2, 1]))  # [0, 1, 2, 9]        


# Question (In place sort)
# Complete the body of the function so it sorts the input list in place (you should not create a new list!).
def my_sort(lst: list[int]) -> None:

    
    start = 0 

    while lst:
        smallest = lst[0]

        for elem in lst:
            for index in range(start, len(lst)):
                if lst[index] < smallest:
                    smallest = lst[index]
            lst.insert(0, smallest)
            start += 1
        

the_lst = [1, 0, 3, 5]
my_sort(the_lst)
print(the_lst)  # [0, 1, 2, 9]